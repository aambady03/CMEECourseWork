======================================================================
AUTOMATED FEEDBACK LOG
======================================================================

HOW TO READ THIS FEEDBACK:
--------------------------
1. This log contains detailed feedback on your code execution
2. Each script is tested and results are shown with output and errors
3. IMPORTANT: Read all the way to the END for a summary and debugging guidance
4. The summary at the end will help you understand and fix any issues
5. Scripts are run in a headless environment (no GUI applications)

======================================================================

Starting testing for Anaga Ambady

Processing week 1

Your current Git repo size is about 1.56 MiB on disk

Found directories: .git, week1, week2, Feedback
Found files: .gitignore, README.md

Processing week 1: week1

Found 8 code files to test.

Note: Expected file checking not performed (no FileList provided).
Expected file checking will only be performed during final assessment.

======================================================================
Script: csvtospace.sh

Contents:

**********
#!/bin/sh
# Author: Anaga Ambady anaga.ambady25@imperial.ac.uk
# Script: csvtospace.sh
# Description: Checks to see if there is an existing input file
# Converts comma seperated file to space-seperated
# Otherwise prints error message and tells user to enter input
# Usage: bash csvtospace.sh <input.csv>
# Date: Oct 2025

#check for input file
if [ -z "$1" ]; then
    echo "Usage: $0 input_file.txt" 
    exit 1
fi

#assign input variable
input="$1"

#check if file exists
if [ ! -f "$input" ]; then
    echo "Error: file '$input' not found"
    exit 1
fi

#create output filename (removes .csv suffix)
outfile="${input%.csv}.txt"


#converts csv to space-seperated and save as file name
tr "," " " < "$input" > "$outfile"


#prints message for user
echo "Success! Creating a space delimited version of $input ..."
echo "Created! Output is saved to $outfile"
exit 0 
**********

Output (first 500 chars):

**********
Usage: csvtospace.sh input_file.txt

**********
No errors.
======================================================================
Script: countlines.sh

Contents:

**********
#!/bin/sh
# Author: Anaga Ambady anaga.ambady25@imperial.ac.uk
# Script: countlines.sh
# Description: Checks if input file exists and is readable 
# Counts the number of lines in file 
# Usage: countlines.sh <inputfile>
# Date: Oct 2025

#check if there is an input file
if [ -z "$1" ]; then
    echo "Usage; $0 <filename>"
    echo "Error: No input file entered"
    exit 1
fi

#check if file exists
if [ ! -f "$1" ]; then
    echo "Error: file '$1' not found"
    exit 1
fi   

# Check if the file is readable
if [ ! -r "$1" ]; then
    echo "Error: '$1' is not readable."
    exit 1
fi

#display line count for file
NumLines=$(wc -l < "$1")
echo "The file $1 has $NumLines lines"
echo
**********

Output (first 500 chars):

**********
Usage; countlines.sh <filename>
Error: No input file entered

**********
No errors.
======================================================================
Script: concatenatetwofiles.sh

Contents:

**********
#!/bin/sh
# Author: Anaga Ambady anaga.ambady25@imperial.ac.uk
# Script: concatenatetwofiles.sh 
# Description: Merges two files into a third empty file ($3)
# Usage: concatenatetwofiles.sh <input.txt> <input2.txt>
# Date: Oct 2025

#check if there is an input file
if [ -z "$1" ]; then
    echo "Usage; $0 <filename>"
    echo "Error: No input file entered"
    exit 1 
fi

#check if file exists
if [ ! -f "$1" ]; then
    echo "Error: file '$1' not found"
    exit 1
fi   

#$1 file contents overwrites $3 
echo "Copying $1 file material to $3"
cat "$1" > "$3"

#appends $2 contents into $3
cat "$2" >> "$3"

#show merged file is completed in new file ($3)
echo
echo "=== New file '$3' is complete ==="
echo "Merged File content:"
echo "---------------------"
cat "$3"
echo "---------------------"
echo
exit 0
**********

Output (first 500 chars):

**********
Usage; concatenatetwofiles.sh <filename>
Error: No input file entered

**********
No errors.
======================================================================
Script: CompileLaTeX.sh

Contents:

**********
#!/bin/bash
pdflatex $1.tex
bibtex $1
pdflatex $1.tex
pdflatex $1.tex
evince $1.pdf &

## Cleanup
rm *.aux
rm *.log
rm *.bbl
rm *.blg



**********

Output (first 500 chars):

**********
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(/usr/share/texlive/texmf-dist/tex/latex/tools/.tex
LaTeX2e <2023-11-01> patch level 1
L3 programming layer <2024-01-22>
File ignored)
*
! Emergency stop.
<*> 
    
!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on .log.
This is pdfTeX, Version 3.141592653-2.6-1.40.25 (TeX Live 2023/Debian) (preloaded format=pdflatex
**********
Errors:
**********
bibtex: Need exactly one file argument.
Try `bibtex --help' for more information.
rm: cannot remove '*.aux': No such file or directory
rm: cannot remove '*.log': No such file or directory
rm: cannot remove '*.bbl': No such file or directory
rm: cannot remove '*.blg': No such file or directory
Cannot parse arguments: Cannot open display: 

**********
======================================================================
Script: tiff2png.sh

Contents:

**********
#!/bin/bash
# Author: Anaga Ambady anaga.ambady25@imperial.ac.uk
# Script: 
# Description: 
# Date: Oct 2025

#check input for tif


for f in ../data/*.tif; 
    do  
        echo "Converting $f"; 
        convert "$f"  "$(basename "$f" .tif).png"; 
    done
**********

Output (first 500 chars):

**********
Converting ../data/*.tif

**********
Errors:
**********
convert-im6.q16: unable to open image `../data/*.tif': No such file or directory @ error/blob.c/OpenBlob/2964.
convert-im6.q16: no images defined `*.png' @ error/convert.c/ConvertImageCommand/3234.

**********
======================================================================
Script: boilerplate.sh

Contents:

**********
#!bin/sh
#Author: aa6725@ic.ac.uk
#Scripts: boilerplate.sh
#Desc: simple boilerplate for shell scripts
#Arguments: none
#Date: Oct 9

echo -e "\nThis is a shell script! \n"

#exit
**********

Output (first 500 chars):

**********

This is a shell script! 


**********
No errors.
======================================================================
Script: tabtocsv.sh

Contents:

**********
#!/bin/sh
# Author: Anaga Ambady anaga.ambady25@imperial.ac.uk
# Script: tabtocsv.sh
# Description: Checks to see if there is an existing input file
# Saves the output into a .csv file
# Otherwise prints error message and tells user to enter input
# Arguments: 1 -> tab delimited file
# Date: Oct 2025

#check for input file
if [ -z "$1" ]; then
    echo "Usage: $0 input_file.txt" 
    exit 1
fi

#check if file exists
if [ ! -f "$1" ]; then
    echo "Error: file '$1' not found"
    exit 1
fi

#removes txt suffix
#convert file to csv and save as file name
outfile="${1%.txt}.csv"

#prints message for user
echo "Creating a comma delimited version of $1 ..."
tr "\t" ","< "$1" > "$outfile"
echo "Done! Output is saved to $outfile"
exit 0
**********

Output (first 500 chars):

**********
Usage: tabtocsv.sh input_file.txt

**********
No errors.
======================================================================
Script: variables.sh

Contents:

**********
#!/bin/sh
# Author: Anaga Ambady anaga.ambady25@imperial.ac.uk
# Script: variables.sh
# Description: Illustrates the use of variables 
# Converts comma seperated file to space-seperated
# Otherwise prints error message and tells user to enter input
# Usage: bash variables.sh <input.csv>
# Date: Oct 2025

# Special variables

echo "This script was called with $# parameters"
echo "The script's name is $0".
echo "The arguments are $1 and $2".
echo "The first argument is $1 and "
echo "the second argument is $2".

# Assigned Variables; Explicit declaration:
MY_VAR='some string' 
echo 'The current value of the variable is:' $MY_VAR
echo
echo 'Please enter a new string'
read MY_VAR


## Assigned Variables; Reading (multiple values) from user input:
echo 'Enter two numbers separated by space(s)'
read a b

MY_SUM=$((a + b))
echo
echo "you entered $a and $b ; Their sum is:"

## Assigned Variables; Command substitution
echo "$MY_SUM"
**********

Output (first 500 chars):

**********
This script was called with 0 parameters
The script's name is variables.sh.
The arguments are  and .
The first argument is  and 
the second argument is .
The current value of the variable is: some string

Please enter a new string
Enter two numbers separated by space(s)

you entered  and  ; Their sum is:
0

**********
No errors.

======================================================================
FEEDBACK SUMMARY
======================================================================

Scripts tested: 14
Scripts successful: 12
Scripts with errors: 2
Warnings/Notes: 1

IMPORTANT DEBUGGING GUIDANCE:
------------------------------

Please review all warnings and errors, and your directory structure based on the above log.

Ask yourself: Why did I not get these warnings or errors on my machine when I tested my code?
Common reasons for environment differences:

• File paths: Your local machine may have different directory structures
• Dependencies: Missing packages or different versions
• File permissions: Scripts may not be executable on the testing server
• Case sensitivity: Linux systems are case-sensitive (your laptop may not be)
• Working directory: Scripts may assume they run from a specific location
• Input files: Required data files may be missing or in wrong locations

Debugging steps:
1. Test your code in a clean environment (fresh directory)
2. Check all file paths are relative and correct
3. Verify all required files are present and properly named
4. Test on a case-sensitive system if possible
5. Run your scripts from different directories to check robustness

Fix these issues and test again. Good debugging skills are essential for scientific computing!

